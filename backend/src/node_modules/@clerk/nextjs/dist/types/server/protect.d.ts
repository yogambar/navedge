import type { AuthObject } from '@clerk/backend';
import type { RedirectFun, SignedInAuthObject } from '@clerk/backend/internal';
import type { CheckAuthorizationFromSessionClaims, CheckAuthorizationParamsFromSessionClaims, OrganizationCustomPermissionKey } from '@clerk/types';
type AuthProtectOptions = {
    /**
     * The URL to redirect the user to if they are not authorized.
     */
    unauthorizedUrl?: string;
    /**
     * The URL to redirect the user to if they are not authenticated.
     */
    unauthenticatedUrl?: string;
};
/**
 * Throws a Nextjs notFound error if user is not authenticated or authorized.
 */
export interface AuthProtect {
    <P extends OrganizationCustomPermissionKey>(params?: CheckAuthorizationParamsFromSessionClaims<P>, options?: AuthProtectOptions): Promise<SignedInAuthObject>;
    (params?: (has: CheckAuthorizationFromSessionClaims) => boolean, options?: AuthProtectOptions): Promise<SignedInAuthObject>;
    (options?: AuthProtectOptions): Promise<SignedInAuthObject>;
}
export declare function createProtect(opts: {
    request: Request;
    authObject: AuthObject;
    /**
     * middleware and pages throw a notFound error if signed out
     * but the middleware needs to throw an error it can catch
     * use this callback to customise the behavior
     */
    notFound: () => never;
    /**
     * see {@link notFound} above
     */
    redirect: (url: string) => void;
    /**
     * protect() in middleware redirects to signInUrl if signed out
     * protect() in pages throws a notFound error if signed out
     * use this callback to customise the behavior
     */
    redirectToSignIn: RedirectFun<unknown>;
}): AuthProtect;
export {};
//# sourceMappingURL=protect.d.ts.map